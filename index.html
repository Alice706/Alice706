<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>try you best</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="shc">
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="try you best">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="try you best">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="try you best">
  
    <link rel="alternate" href="/atom.xml" title="try you best" type="application/atom+xml">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">try you best</a></h1>
    <p><a href="/"></a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
      
        <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content">




  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/08/13/node-js/">
  <time datetime="2017-08-13T02:32:23.284Z">
    2017-08-13
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/08/13/node-js/">nodejs</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p><a href="http://blog.csdn.net/zhangxin09/article/details/5836777" target="_blank" rel="external">nodejs一篇非常好的博客</a><br><strong>nodejs</strong></p>
<ul>
<li>v8 是非常快的js引擎，处理js执行运行的速度非常高</li>
<li>定义：运行在服务端的js</li>
<li><ol>
<li>引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。</li>
</ol>
</li>
</ul>
<ol>
<li>创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。</li>
<li>接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。</li>
</ol>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/08/13/Mongodb/">
  <time datetime="2017-08-13T02:31:52.086Z">
    2017-08-13
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/08/13/Mongodb/">Mongodb</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p><strong>定义</strong></p>
<ul>
<li>MongoDB是一个可扩展的，高性能的开源NoSQL数据库。</li>
</ul>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/08/11/作用域、沙箱、闭包/">
  <time datetime="2017-08-11T13:45:45.752Z">
    2017-08-11
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/08/11/作用域、沙箱、闭包/">作用域、沙箱、闭包</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p><strong>作用域</strong></p>
<ul>
<li>变量起作用的区域</li>
<li>作用域链：在一个函数内部嵌套另外一个函数<br>注：不管在哪里调用，只管在哪里创建</li>
</ul>
<hr>
<p><strong>闭包</strong></p>
<ul>
<li>定义：在函数内部定义的变量，在函数外部无法访问</li>
</ul>
<ol>
<li>js中所有的函数都能形成闭包</li>
<li>函数里面包裹其他函数，并且返回这个函数<br><div style="background-color:#eee;padding:10px"><br> function fn () {<br> var num = 123;<br> return function () {</div></li>
</ol>
<p>}<br>}<br>var n = fn();//结果：return 后面的函数体<br>n();<br></p>
<hr>
<p><strong>沙箱模式（自调用）</strong><br>作用：用于为一些来源不可信，无法判定意图的程序提供试验环境，对变量进行隔离<br>目的：减少全局污染<br>(function(){</p>
<p>})()</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/08/11/函数/">
  <time datetime="2017-08-11T13:16:06.074Z">
    2017-08-11
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/08/11/函数/">函数</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p><strong>创建函数的几种方式</strong></p>
<ol>
<li>字面量<ul>
<li>function fn () { }</li>
</ul>
</li>
<li>函数表达式<ul>
<li>var fn =function () { }</li>
</ul>
</li>
<li>构造函数<ul>
<li>var fn = new Function ();</li>
<li>var fn = new Function(‘hello’);</li>
</ul>
</li>
<li>自定义构造函数<ul>
<li>function Fn () { }<br>var fn = new Fn();</li>
</ul>
<hr>
<strong>callee和caller</strong><ul>
<li>callee:argument对象所在的函数<br>作用：在函数内部指向函数自身<br>function fn (1,2,3) {<br>arguments.callee;//结果：这个函数体<br>arguments.callee();//递归<br>}  </li>
<li>caller呼叫者<br>作用：显示该函数的调用者<br>如果fn()在全局调用，返回结果为<strong>null</strong><br>function fn (a,b) {<br>console.log(fn.caller);<br>}<br>function fn1 ( ) {<br>fn();<br>}</li>
</ul>
</li>
</ol>
<p>返回：function fn1 () {<br>    fn();<br>}</p>
<hr>
<p><strong>函数的四种调用模式</strong></p>
<ol>
<li>函数调用模式</li>
<li>方法调用模式</li>
<li>构造函数调用模式</li>
<li>上下文调用模式（借用）apply()/call()</li>
</ol>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/08/11/对象/">
  <time datetime="2017-08-11T11:27:53.450Z">
    2017-08-11
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/08/11/对象/">对象、面向对象、原型</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p><strong><h2>对象</h2></strong></p>
<ul>
<li>无序的键值对的集合</li>
<li><p>创建对象的方式</p>
<ol>
<li>字面量：var obj = { } //缺点：大量使用时，代码的复用性太低</li>
<li>构造函数：var obj = new Object();//代码复用性更低</li>
<li>自定义构造函数：function Obj() { } var obj1 = new Obj();var obj2 = new Obj();<ul>
<li>执行过程：  </li>
</ul>
<ol>
<li>创建一个对象  </li>
<li>让this 指向这个对象  </li>
<li>执行构造函数  </li>
<li>返回这个对象</li>
</ol>
</li>
<li>实例：对象，实例化：创建对象的过程</li>
<li>静态方法和实例方法</li>
</ol>
<ul>
<li><p>静态方法：函数名.方法名</p>
</li>
<li><p>实例方法：对象名.方法名</p>
</li>
<li>如何给对象添加属性和方法<ol>
<li>添加到原型上</li>
<li>让原型指向这个对象</li>
</ol>
</li>
</ul>
</li>
<li><p>注：对象的返回值是引用类型时，返回的结果就是引用类型</p>
</li>
</ul>
<hr>
<p><strong>原型</strong></p>
<ul>
<li>概念：每个构造函数在创建出来的时候，系统会自动给这个构造函数创建并关联一个空对象，这个对象就是原型</li>
<li>在原型中定义的方法和属性，会被这个构造函数创建出来的对象共享</li>
</ul>
<p><strong><h2>面向对象</h2></strong></p>
<ul>
<li>面向对象就是面向过程的封装</li>
<li>面向对象是一种编程思想</li>
<li>原型链：对象有原型，原型本身又是一个对象，所以原型也有原型</li>
<li>三大特性<ul>
<li>封装（可拓展性）对象对属性和方法的封装</li>
<li>继承 （重用性）一个对象想拥有另外一个对象的属性和方法</li>
<li>多态（可维护，可拓展）在Js中没有多态</li>
</ul>
<hr>
<strong><h2>经典继承</h2></strong></li>
</ul>
<ol>
<li>简单混入  for … in(缺点：复用性低)<div style="background-color:#eee;padding:10px;margin:10px;"> var obj = {<br>name : ‘nacy’;<br>}<br>var obj1 = {};<br>for (var k in obj){<br>obj1[k] = obj[k]<br>}<br></div><br>2. 原型混入<br>- for … in 添加到原型中<br>- 替换原型<br><div style="background-color:#eee;padding:10px;margin:10px"><br>var obj = {<br>name : “nacy”<br>}<br>function Person () {}<br>var person = new Person();<br>p.prototype = obj;<br></div><br>3. Object.create()<br><div style="background-color:#eee;padding:10px;margin:10px"><br> var obj = {<br> name:’nacy’<br>}<br>var obj1 = Object.create(obj);//好用，es6的新语法，有兼容性<br></div>
</li>
</ol>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/08/10/git和github/">
  <time datetime="2017-08-10T13:11:45.272Z">
    2017-08-10
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/08/10/git和github/">git,github</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p><strong>git(分布式版本控制工具)</strong></p>
<ul>
<li>Git 是一种专为处理文本文件而设计的版本控制系统</li>
<li>分支进行多任务开发</li>
</ul>
<p><a href="http://blog.jobbole.com/111187/" target="_blank" rel="external">大白话解释的链接</a></p>
<p><strong>github</strong></p>
<ul>
<li>github是全球最大的源代码托管平台</li>
<li>Github 获取 Git 中的提交历史，并将其存储在互联网上，因此你可以从任一一台电脑访问它</li>
<li>Github 就是让你把工作（通过Git提交进行注解）存储在了一个指定的在线文件夹（repo）</li>
</ul>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/08/09/cookie和session/">
  <time datetime="2017-08-09T08:34:19.061Z">
    2017-08-09
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/08/09/cookie和session/">cookie和session</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p><strong>为什么会出现cookie和session</strong></p>
<ul>
<li>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session(比如：购物车)</li>
<li>HTTP协议是无状态的协议，一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话</li>
</ul>
<ol>
<li><strong>cookie机制和session机制的区别</strong></li>
</ol>
<ul>
<li>cookie是存储在客户端，session机制采用的是在服务端保持状态的方案</li>
<li><p>session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）</p>
</li>
<li><p>由于在服务端保持状态的方案在客户端也需要保持一个标识，所以session机制可能需要借助cookie机制达到保存标识的目的</p>
</li>
</ul>
<ol>
<li><strong>过期时间</strong></li>
</ol>
<ul>
<li>（会话cookie）cookie默认生命周期为浏览器关闭，cookie消失，保存在内存中</li>
<li>（持久cookie）设置了周期，会被保存到硬盘上</li>
</ul>
<hr>
<p><a href="http://www.blogjava.net/cheneyfree/archive/2007/05/26/120168.html" target="_blank" rel="external">详细解释的网址</a><br><a href="http://blog.csdn.net/bigpudding24/article/details/51156146" target="_blank" rel="external">一篇好的博客</a></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/08/09/流式布局，响应式布局和rem/">
  <time datetime="2017-08-09T08:24:43.082Z">
    2017-08-09
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/08/09/流式布局，响应式布局和rem/">流式布局，响应式布局，弹性布局和rem</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p><strong>响应式布局</strong></p>
<ul>
<li>检测设备，根据不同的设备采用不同的css，响应式的模板在不同的设备上看上去是不一样的</li>
<li>是流式布局与自适应布局设计理念的融合</li>
<li>响应式布局可以根据屏幕的大小自动的调整页面的展现方式，以及布局</li>
<li>缺点：只能适应主流的宽高</li>
<li>响应式布局一般配合媒体查询，视口一起使用，来开发一个：能兼容多个终端，而不必多次开发</li>
</ul>
<hr>
<p><strong>流式布局（百分比布局）</strong></p>
<ul>
<li>特点：高度按照px，宽度是百分比</li>
<li>展示的方式像流水一样，一部分一部分的加载</li>
<li>缺点：能适应各种屏幕，但是显示效果差，往往只能适应几个手机屏幕</li>
<li>流式布局一般偏向于文字展示的页面，对整个页面比例要求不那么高的。</li>
</ul>
<hr>
<p><strong>伸缩布局</strong></p>
<ul>
<li>该元素内部的子元素的float,clear,vertical-align属性统统失效</li>
</ul>
<p><strong>rem</strong></p>
<ul>
<li>是指相对于根元素的字体大小的单位，是一个相对单位</li>
<li>一般用于web app开发</li>
<li>rem能等比例适配所有的屏幕</li>
<li>rem就是偏向于图片较多，不出现滚动条的满屏页面，且高度还原设计图比例的情况</li>
<li>两种写法</li>
</ul>
<ol>
<li><div style="background-color:#eee;padding:10px;"><br> html {<br> font-size : 20px;<br>}<br>@media only screen and (min-width: 401px){<br> html {<br>     font-size: 25px !important;<br> }<br>}<br>@media only screen and (min-width: 428px){<br> html {<br>     font-size: 26.75px !important;<br> }<br>}<br></div>

</li>
</ol>
<p><strong>总结</strong><br>1.如果只做pc端</p>
<p>那么定宽度是最好的选择</p>
<p>2.如果做移动端，且设计对高度要求不高</p>
<p>那么rem+js是最好的选择，一份css+一份js调节font-size搞定</p>
<p>3.如果pc，移动要兼容，而且要求很高</p>
<p>那么响应式布局还是最好的选择，前提是设计根据不同的高宽做不同的设计，</p>
<p>响应式根据媒体查询做不同的布局。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/08/09/jQuery/">
  <time datetime="2017-08-09T02:32:36.486Z">
    2017-08-09
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/08/09/jQuery/">jQuery</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h2 id="jQuery就是js的一个库，把一些常用的功能进行了封装，方便我们调用，提高开发效率"><a href="#jQuery就是js的一个库，把一些常用的功能进行了封装，方便我们调用，提高开发效率" class="headerlink" title="jQuery就是js的一个库，把一些常用的功能进行了封装，方便我们调用，提高开发效率"></a>jQuery就是js的一个库，把一些常用的功能进行了封装，方便我们调用，提高开发效率</h2><ul>
<li>jQuery能做的js都能做，js能做的jq不一定能做</li>
<li>jq等文档加载完就加载，js是等文档和图片都加载完<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2></li>
<li><p>jQuery.fn.init的功能是对传进来的selector参数进行分析，进行各种不同的处理，然后生成jQuery对象。</p>
</li>
<li><p>代码 </p>
<div style="background-color:#eee;padding:10px;"><br> (function (window,undefined) {<br>      var jQuery = function () {<br>          //工厂函数<br>          return new jQuery.prototype.init();<br>      }<br>      jQuery.prototpye = {<br>          init : function () {<br>          }<br>      }<br>      jQuery.prototype.init.prototype = jQuery.prototype;<br><br>      window.$ = window.jQuery = jQuery;<br><br> })(window);<br><br></div>

</li>
</ul>
<h3 id="好的文章链接"><a href="#好的文章链接" class="headerlink" title="好的文章链接"></a>好的文章链接</h3><ul>
<li><a href="http://www.cnblogs.com/yangjunhua/archive/2012/12/27/2835989.html" target="_blank" rel="external">jQuery基础框架</a></li>
</ul>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/08/08/html部分整理/">
  <time datetime="2017-08-08T13:46:59.999Z">
    2017-08-08
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/08/08/html部分整理/">html部分整理</a></h1>
  

  </header>
  
  <div class="entry">
    
      
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  

  <nav id="pagination">
  
  
    <a href="/page/2/" class="next">下一页</a>
  
  <div class="clearfix"></div>
</nav>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2017 <a href="/">shc</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>