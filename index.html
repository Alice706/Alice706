<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>try you best</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="shc">
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="try you best">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="try you best">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="try you best">
  
    <link rel="alternate" href="/atom.xml" title="try you best" type="application/atom+xml">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">try you best</a></h1>
    <p><a href="/"></a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
      
        <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content">




  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/08/13/Mongodb/">
  <time datetime="2017-08-13T02:31:52.086Z">
    2017-08-13
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/08/13/Mongodb/">Mongodb</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p><strong>定义</strong></p>
<ul>
<li>MongoDB是一个可扩展的，高性能的开源NoSQL数据库。</li>
</ul>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/08/08/html部分整理/">
  <time datetime="2017-08-08T13:46:59.999Z">
    2017-08-08
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/08/08/html部分整理/">html部分整理</a></h1>
  

  </header>
  
  <div class="entry">
    
      
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/05/11/函数/">
  <time datetime="2017-05-11T13:16:06.000Z">
    2017-05-11
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/05/11/函数/">函数</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p><strong>创建函数的几种方式</strong></p>
<ol>
<li>字面量<ul>
<li>function fn () { }</li>
</ul>
</li>
<li>函数表达式<ul>
<li>var fn =function () { }</li>
</ul>
</li>
<li>构造函数<ul>
<li>var fn = new Function ();</li>
<li>var fn = new Function(‘hello’);</li>
</ul>
</li>
<li>自定义构造函数<ul>
<li>function Fn () { }<br>var fn = new Fn();</li>
</ul>
<hr>
<strong>callee和caller</strong><ul>
<li>callee:argument对象所在的函数<br>作用：在函数内部指向函数自身<br>function fn (1,2,3) {<br>arguments.callee;//结果：这个函数体<br>arguments.callee();//递归<br>}  </li>
<li>caller呼叫者<br>作用：显示该函数的调用者<br>如果fn()在全局调用，返回结果为<strong>null</strong><br>function fn (a,b) {<br>console.log(fn.caller);<br>}<br>function fn1 ( ) {<br>fn();<br>}</li>
</ul>
</li>
</ol>
<p>返回：function fn1 () {<br>    fn();<br>}</p>
<hr>
<p><strong>函数的四种调用模式</strong></p>
<ol>
<li>函数调用模式</li>
<li>方法调用模式</li>
<li>构造函数调用模式</li>
<li>上下文调用模式（借用）apply()/call()</li>
</ol>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/04/11/对象/">
  <time datetime="2017-04-11T11:27:53.000Z">
    2017-04-11
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/04/11/对象/">对象、面向对象、原型</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p><strong><h2>对象</h2></strong></p>
<ul>
<li>无序的键值对的集合</li>
<li><p>创建对象的方式</p>
<ol>
<li>字面量：var obj = { } //缺点：大量使用时，代码的复用性太低</li>
<li>构造函数：var obj = new Object();//代码复用性更低</li>
<li>自定义构造函数：function Obj() { } var obj1 = new Obj();var obj2 = new Obj();<ul>
<li>执行过程：  </li>
</ul>
<ol>
<li>创建一个对象  </li>
<li>让this 指向这个对象  </li>
<li>执行构造函数  </li>
<li>返回这个对象</li>
</ol>
</li>
<li>实例：对象，实例化：创建对象的过程</li>
<li>静态方法和实例方法</li>
</ol>
<ul>
<li><p>静态方法：函数名.方法名</p>
</li>
<li><p>实例方法：对象名.方法名</p>
</li>
<li>如何给对象添加属性和方法<ol>
<li>添加到原型上</li>
<li>让原型指向这个对象</li>
</ol>
</li>
</ul>
</li>
<li><p>注：对象的返回值是引用类型时，返回的结果就是引用类型</p>
</li>
</ul>
<hr>
<p><strong>原型</strong></p>
<ul>
<li>概念：每个构造函数在创建出来的时候，系统会自动给这个构造函数创建并关联一个空对象，这个对象就是原型</li>
<li>在原型中定义的方法和属性，会被这个构造函数创建出来的对象共享</li>
</ul>
<p><strong><h2>面向对象</h2></strong></p>
<ul>
<li>面向对象就是面向过程的封装</li>
<li>面向对象是一种编程思想</li>
<li>原型链：对象有原型，原型本身又是一个对象，所以原型也有原型</li>
<li>三大特性<ul>
<li>封装（可拓展性）对象对属性和方法的封装</li>
<li>继承 （重用性）一个对象想拥有另外一个对象的属性和方法</li>
<li>多态（可维护，可拓展）在Js中没有多态</li>
</ul>
<hr>
<strong><h2>经典继承</h2></strong></li>
</ul>
<ol>
<li>简单混入  for … in(缺点：复用性低)<div style="background-color:#eee;padding:10px;margin:10px;"> var obj = {<br>name : ‘nacy’;<br>}<br>var obj1 = {};<br>for (var k in obj){<br>obj1[k] = obj[k]<br>}<br></div><br>2. 原型混入<br>- for … in 添加到原型中<br>- 替换原型<br><div style="background-color:#eee;padding:10px;margin:10px"><br>var obj = {<br>name : “nacy”<br>}<br>function Person () {}<br>var person = new Person();<br>p.prototype = obj;<br></div><br>3. Object.create()<br><div style="background-color:#eee;padding:10px;margin:10px"><br> var obj = {<br> name:’nacy’<br>}<br>var obj1 = Object.create(obj);//好用，es6的新语法，有兼容性<br></div>
</li>
</ol>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/03/20/git和github/">
  <time datetime="2017-03-20T13:11:45.000Z">
    2017-03-20
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/03/20/git和github/">git,github</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p><strong>git(分布式版本控制工具)</strong></p>
<ul>
<li>Git 是一种专为处理文本文件而设计的版本控制系统</li>
<li>分支进行多任务开发</li>
</ul>
<p><a href="http://blog.jobbole.com/111187/" target="_blank" rel="external">大白话解释的链接</a></p>
<p><strong>github</strong></p>
<ul>
<li>github是全球最大的源代码托管平台</li>
<li>Github 获取 Git 中的提交历史，并将其存储在互联网上，因此你可以从任一一台电脑访问它</li>
<li>Github 就是让你把工作（通过Git提交进行注解）存储在了一个指定的在线文件夹（repo）</li>
</ul>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/03/09/cookie和session/">
  <time datetime="2017-03-09T08:34:19.000Z">
    2017-03-09
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/03/09/cookie和session/">cookie和session</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p><strong>为什么会出现cookie和session</strong></p>
<ul>
<li>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session(比如：购物车)</li>
<li>HTTP协议是无状态的协议，一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话</li>
</ul>
<ol>
<li><strong>cookie机制和session机制的区别</strong></li>
</ol>
<ul>
<li>cookie是存储在客户端，session机制采用的是在服务端保持状态的方案</li>
<li><p>session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）</p>
</li>
<li><p>由于在服务端保持状态的方案在客户端也需要保持一个标识，所以session机制可能需要借助cookie机制达到保存标识的目的</p>
</li>
</ul>
<ol>
<li><strong>过期时间</strong></li>
</ol>
<ul>
<li>（会话cookie）cookie默认生命周期为浏览器关闭，cookie消失，保存在内存中</li>
<li>（持久cookie）设置了周期，会被保存到硬盘上</li>
</ul>
<hr>
<p><a href="http://www.blogjava.net/cheneyfree/archive/2007/05/26/120168.html" target="_blank" rel="external">详细解释的网址</a><br><a href="http://blog.csdn.net/bigpudding24/article/details/51156146" target="_blank" rel="external">一篇好的博客</a></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/02/09/流式布局，响应式布局和rem/">
  <time datetime="2017-02-09T08:24:43.000Z">
    2017-02-09
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/02/09/流式布局，响应式布局和rem/">流式布局，响应式布局，弹性布局和rem</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p><strong>响应式布局</strong></p>
<ul>
<li>检测设备，根据不同的设备采用不同的css，响应式的模板在不同的设备上看上去是不一样的</li>
<li>是流式布局与自适应布局设计理念的融合</li>
<li>响应式布局可以根据屏幕的大小自动的调整页面的展现方式，以及布局</li>
<li>缺点：只能适应主流的宽高</li>
<li>响应式布局一般配合媒体查询，视口一起使用，来开发一个：能兼容多个终端，而不必多次开发</li>
</ul>
<hr>
<p><strong>流式布局（百分比布局）</strong></p>
<ul>
<li>特点：高度按照px，宽度是百分比</li>
<li>展示的方式像流水一样，一部分一部分的加载</li>
<li>缺点：能适应各种屏幕，但是显示效果差，往往只能适应几个手机屏幕</li>
<li>流式布局一般偏向于文字展示的页面，对整个页面比例要求不那么高的。</li>
</ul>
<hr>
<p><strong>伸缩布局</strong></p>
<ul>
<li>该元素内部的子元素的float,clear,vertical-align属性统统失效</li>
</ul>
<p><strong>rem</strong></p>
<ul>
<li>是指相对于根元素的字体大小的单位，是一个相对单位</li>
<li>一般用于web app开发</li>
<li>rem能等比例适配所有的屏幕</li>
<li>rem就是偏向于图片较多，不出现滚动条的满屏页面，且高度还原设计图比例的情况</li>
<li>两种写法</li>
</ul>
<ol>
<li><div style="background-color:#eee;padding:10px;"><br> html {<br> font-size : 20px;<br>}<br>@media only screen and (min-width: 401px){<br> html {<br>     font-size: 25px !important;<br> }<br>}<br>@media only screen and (min-width: 428px){<br> html {<br>     font-size: 26.75px !important;<br> }<br>}<br></div>

</li>
</ol>
<p><strong>总结</strong><br>1.如果只做pc端</p>
<p>那么定宽度是最好的选择</p>
<p>2.如果做移动端，且设计对高度要求不高</p>
<p>那么rem+js是最好的选择，一份css+一份js调节font-size搞定</p>
<p>3.如果pc，移动要兼容，而且要求很高</p>
<p>那么响应式布局还是最好的选择，前提是设计根据不同的高宽做不同的设计，</p>
<p>响应式根据媒体查询做不同的布局。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/01/04/ajax和json以及jsonP/">
  <time datetime="2017-01-04T10:54:52.000Z">
    2017-01-04
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/01/04/ajax和json以及jsonP/">ajax和json以及jsonp</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><ul>
<li><strong>目的</strong>:同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</li>
<li><strong>限制</strong><div style="background-color:#eee; padding:10px">    1. cookie、localStorage 和 indexDB无法读取<br>  2. dom 无法获取<br>  3. AJAX 请求不能发送 </div>       </li>
<li><strong>规定</strong>：不同域的客户端脚本在没有明确授权的情况下，不能读写对方的资源        </li>
<li><strong>同源</strong>：协议、域名、端口号完全一致</li>
<li><strong>url的组成</strong>：协议 域名 端口号 路径 参数 哈希值</li>
<li><strong>同源策略阮一峰的博客有写</strong></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="external">链接到阮一峰的博客</a></li>
</ul>
<hr>
<h2 id="AJAX-异步-Javascript-和-xml"><a href="#AJAX-异步-Javascript-和-xml" class="headerlink" title="AJAX(异步 Javascript 和 xml)"></a>AJAX(异步 Javascript 和 xml)</h2><h3 id="本质：在http协议的基础上，以异步的方式与服务器进行通信"><a href="#本质：在http协议的基础上，以异步的方式与服务器进行通信" class="headerlink" title="本质：在http协议的基础上，以异步的方式与服务器进行通信"></a>本质：在http协议的基础上，以异步的方式与服务器进行通信</h3><p>XMLHTTPREQUEST通过在后台与服务器进行少量数据交互，实现页面异步更新<br><strong>异步</strong>：某段程序执行时，不会阻塞其他程序的执行</p>
<ol>
<li><strong>ajax是以何种格式来交互数据的？跨域的问题如何解决</strong><br>首选方案：json传输数据，jsonp实现跨域</li>
<li><strong>ajax解决同源策略的方案</strong><br><div style="background-color:#eee;padding:10px">    -JSONP<br> -WebSocket<br> -CORS：跨域资源分享，允许任何类型的请求<br></div><h5 id="优点：异步通信，实现页面局部刷新，按需获取数据，节约宽带资源，带来更好的用户体验"><a href="#优点：异步通信，实现页面局部刷新，按需获取数据，节约宽带资源，带来更好的用户体验" class="headerlink" title="优点：异步通信，实现页面局部刷新，按需获取数据，节约宽带资源，带来更好的用户体验"></a>优点：异步通信，实现页面局部刷新，按需获取数据，节约宽带资源，带来更好的用户体验</h5><h5 id="缺点：不支持浏览器back按钮，暴露了与服务器交互的细节，对搜索引擎支持比较弱，不能很好的支持移动设备"><a href="#缺点：不支持浏览器back按钮，暴露了与服务器交互的细节，对搜索引擎支持比较弱，不能很好的支持移动设备" class="headerlink" title="缺点：不支持浏览器back按钮，暴露了与服务器交互的细节，对搜索引擎支持比较弱，不能很好的支持移动设备"></a>缺点：不支持浏览器back按钮，暴露了与服务器交互的细节，对搜索引擎支持比较弱，不能很好的支持移动设备</h5></li>
</ol>
<hr>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ul>
<li>JSON是一种轻量级的数据交换格式，用于在浏览器和服务器之间交换信息，本质是字符串</li>
<li>JSON和JS对象互转<br>对象转换成JSON字符串：var json=JSON.stringify();<br>JSON转换成对象：var obj=JSON.parse();</li>
</ul>
<hr>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><ol>
<li>与jsonp息息相关的是script标签，而xhr即ajax与之没有半毛钱关系</li>
<li>由于同源策略的限制，XmlHttpRequest（浏览器的内置对象，用来与后台交互信息）只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求，这就是jsonp的核心。</li>
<li><strong>jsonp是非官方跨域数据交互协议</strong></li>
<li><strong>可以跨域的标签</strong>：在浏览器中，对于标签 script、img、iframe、link 等标签都可以跨域加载资源，而不受同源策略的限制。这些带有“src”属性的标签每次加载的时候，实际上是由浏览器发起一个get请求</li>
</ol>
<hr>
<h2 id="json和jsonp的比较"><a href="#json和jsonp的比较" class="headerlink" title="json和jsonp的比较"></a>json和jsonp的比较</h2><ul>
<li>JSON是一种数据格式，JSONP是一种数据调用方式</li>
<li>json是理想的数据交换格式，但没办法跨域直接获取，于是就将json包裹(padding)在一个合法的js语句中作为js文件传过去。这就是json和jsonp的区别，json是想要的东西，jsonp是达到这个目的而普遍采用的一种方法，当然最终获得和处理的还是json。所以说json是目的，jsonp只是手段。json总会用到，而jsonp只有在跨域获取数据才会用到。<h2 id="ajax和jsonp的对比"><a href="#ajax和jsonp的对比" class="headerlink" title="ajax和jsonp的对比"></a>ajax和jsonp的对比</h2></li>
</ul>
<ol>
<li>相同点：都是请求一个url</li>
<li>不同点：AJAX是通过XMLHTTPREQUEST对象获取非页面内容（后台数据），而JSONP是动态的添加<strong>script</strong>标签来调用服务器提供的js脚本。</li>
<li>ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取</li>
</ol>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/12/05/AMD和CMD/">
  <time datetime="2016-12-05T11:56:54.000Z">
    2016-12-05
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/12/05/AMD和CMD/">require.js</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h2 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h2><ul>
<li>将指定功能的内容划分成一个个的模块，提高复用性，容易维护和管理<h2 id="AMD异步模块定义（Asynchronous-Module-Definition）"><a href="#AMD异步模块定义（Asynchronous-Module-Definition）" class="headerlink" title="AMD异步模块定义（Asynchronous Module Definition）"></a>AMD异步模块定义（Asynchronous Module Definition）</h2></li>
<li><strong>AMD是如何出生的</strong><br>  09年由于node.js的诞生，将js语言用于服务端编程，标志了js模块化编程的正式诞生，那么有了服务端的模块，很自然的，大家就想要客户端的模块，于是AMD诞生了    </li>
<li>模块：就是实现一组特定功能的方法</li>
<li>异步的方式加载模块，不会影响后面的语句运行，所有依赖这个模块的语句，都定义在一个回调函数中，等加载完成以后，这个回调函数才会运行</li>
<li>AMD是提前执行</li>
</ul>
<hr>
<h2 id="require-js"><a href="#require-js" class="headerlink" title="require.js"></a>require.js</h2><ul>
<li>为什么会出现：1：管理模块之间的依赖性，便于代码的编写和维护，复用性<br>2：实现js文件的异步加载，避免网页失去响应</li>
<li>遵循的标准：AMD</li>
<li>建议：<br>  如果是开发的网站含有大量的js代码，并且大多数是自己编写的js，或者开发webapp，游戏，那么推荐用requirejs；如果开发的网站含有大量第三方插件，建议放弃requirejs</li>
<li>概念：requirejs是一个js模块的加载器，可以提高js的加载速度，避免不必要的阻塞</li>
<li>原理：1、把所有js文件交给requirejs来管理，页面中只有一个js文件，让data-mian指向main.js文件</li>
</ul>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/10/07/gulp和webpack/">
  <time datetime="2016-10-07T11:12:51.000Z">
    2016-10-07
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/10/07/gulp和webpack/">gulp和webpack</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p><strong>gulp</strong></p>
<ol>
<li><ul>
<li>是什么：是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器，是基于node.js的自动任务运行器，所以要使用Node必须先安装nodejs</li>
<li>能够自动的完成文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤</li>
</ul>
</li>
<li>前端构建工具都具有的功能：文件的<strong>压缩、合并</strong><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2></li>
</ol>
<ul>
<li>全局安装 gulp，具体方法可以去gulp官网跟着后面输入命令行就行了</li>
<li>在项目的根目录创建gulpfile.js文件<br>写需要引用的插件：<div style="background-color:#eee;padding:10px;">    var gulp     = require(‘gulp’),<br>  concat   = require(‘gulp-concat’),//- 多个文件合并为一个；<br>  cleanCSS = require(‘gulp-clean-css’),//- 压缩CSS为一行；<br>  ugLify   = require(‘gulp-uglify’),//压缩js<br>  imageMin = require(‘gulp-imagemin’),//压缩图片<br>  pngquant = require(‘imagemin-pngquant’), // 深度压缩<br>  htmlMin  = require(‘gulp-htmlmin’),//压缩html<br>  changed  = require(‘gulp-changed’),//检查改变状态<br>  less     = require(‘gulp-less’)//压缩合并less<br>  del      = require(‘del’)<br>  browserSync = require(“browser-sync”).create();//浏览器实时刷新 </div> 


</li>
</ul>
<ul>
<li>gulp的常用插件安装：<div style="background-color:#eee;padding:10px">在根目录npm install gulp gulp-concat gulp-clean-css gulp-uglify gulp-imagemin imagemin-pngquant gulp-htmlmin gulp-changed gulp-less del browser-sync –save-dev。<br></div>

</li>
</ul>
<p><a href="http://blog.csdn.net/beverley__/article/details/55213235" target="_blank" rel="external">详细介绍用法的博客地址</a></p>
<hr>
<p><strong>webpack</strong><br><a href="http://www.jianshu.com/p/42e11515c10f#" target="_blank" rel="external">简单入门</a><br><a href="https://github.com/slashhuang/blog/issues/1" target="_blank" rel="external">github上的相关了解</a><br><a href="http://mlxiao.com/2017/02/08/webpack/" target="_blank" rel="external">好的相关文章链接</a></p>
<ul>
<li>，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack在很多场景下可以替代Gulp/Grunt类的工具。</li>
<li>Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件</li>
</ul>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  

  <nav id="pagination">
  
  
    <a href="/page/2/" class="next">下一页</a>
  
  <div class="clearfix"></div>
</nav>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2017 <a href="/">shc</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>